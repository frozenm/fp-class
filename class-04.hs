{-
  Все задачи в этом задании должны решаться исключительно с помощью свёрток.
  Явная рекурсия не допускается. Если в решении в качестве вспомогательной
  требуется стандартная функция обработки списков (помимо fold*, scan*), она
  также должна реализовываться свёрткой.

  Каждое решение должно сопровождаться тремя различными тестовыми примерами, которые при запуске
  возвращают True, например:

  f = undefined -- решение 
  f_test1 = f undefined == undefined -- тест 1
  f_test2 = f undefined == undefined -- тест 2
  f_test3 = f undefined == undefined -- тест 3
-}

-- 1. Простейшие функции обработки списков

--  a) Найти сумму чётных элементов списка с целочисленными элементами.
f1a :: [Int] -> Int
f1a = foldl (\c x -> c + if even x then x else 0) 0
f1a_test1 = f1a [1,2,3,4,5,6] == 12
f1a_test2 = f1a [3,(-2),8,7,11] == 6
f1a_test3 = f1a [3,7,9] == 0

--  b) Найти сумму и произведение элементов списка вещественных чисел.
f1b :: [Double] -> (Double, Double)
f1b = foldl (\(s,p) x -> (s+x, p*x)) (0,1)
f1b_test1 = f1b [1..6] == (21,720)
f1b_test2 = f1b [3.2, 2.4, 5.0] == (10.6,38.4)
f1b_test3 = f1b [3.0,0.0,9.2] == (12.2,0)

--  с) Найти среднее арифметическое элементов списка вещественных чисел (функцией length пользоваться нельзя,
--     решение должно выполняться в один проход).
f1c :: [Double] -> Double
f1c xs = snd res / (fst res)
  where
    res = foldl (\(c,a) x -> (c+1, a+x)) (0,0) xs
f1c_test1 = f1c [1..6] == 3.5
f1c_test2 = f1c [3,(-2),8,7,11] == 5.4
f1c_test3 = f1c [3,0,9] == 4

--  d) Найти минимальный элемент списка.
f1d :: Ord a => [a] -> a
f1d = foldl1 min 
f1d_test1 = f1d [1..6] == 1
f1d_test2 = f1d [3,(-2),8,7,11] == (-2)
f1d_test3 = f1d [3,0,9] == 0

--  e) Найти наименьший нечётный элемент списка с целочисленными значениями (дополнительным параметром
--     функции должно быть значение, возвращаемое по умолчанию).
f1e :: Int -> [Int] -> Int
f1e d xs = fst $ foldl (\(y,flag) x -> if odd x then (if flag then (min x y, True) else (x, True)) else (y, flag)) (d, False) xs
f1e_test1 = f1e (-1) [1..6] == 1
f1e_test2 = f1e (-1) [4,(-2),8,6] == (-1)
f1e_test3 = f1e (-1) [9,0,3] == 3


-- 2. Свёртки, формирующие списки

--  a) Сформировать список, содержащий каждый второй элемент исходного.
f2a :: [a] -> [a]
f2a xs = snd $ foldl (\(i,acc) x -> if even i then (i+1, acc ++ [x]) else (i+1, acc)) (1,[]) xs
f2a_test1 = f2a [1,2,3,4,5,6] == [2,4,6]
f2a_test2 = f2a [3,(-2),8,7,11] == [(-2),7]
f2a_test3 = f2a [3,0,9] == [0]

--  b) Сформировать список, содержащий первые n элементов исходного.
f2b :: Int -> [a] -> [a]
f2b n xs = snd $ foldl (\(i,acc) x -> if (i <= n) then (i+1, acc ++ [x]) else (i+1, acc)) (1,[]) xs
f2b_test1 = f2b 3 [1,2,3,4,5,6] == [1,2,3]
f2b_test2 = f2b 4 [3,(-2),8,7,11] == [3,(-2),8,7]
f2b_test3 = f2b 1 [3,0,9] == [3]

--  c) Сформировать список, содержащий последние n элементов исходного.
f2c :: Int -> [a] -> [a]
f2c n xs = snd $ foldr (\x (i,acc) -> if (i <= n) then (i+1, x:acc) else (i+1, acc)) (1,[]) xs
f2c_test1 = f2c 3 [1,2,3,4,5,6] == [4,5,6]
f2c_test2 = f2c 4 [3,(-2),8,7,11] == [(-2),8,7,11]
f2c_test3 = f2c 1 [3,0,9] == [9]

--  d) Сформировать список, содержащий все элементы исходного списка, большие левого соседа.
f2d :: Ord a => [a] -> [a]
f2d [] = []
f2d (x:xs) = snd $ foldl (\(x,acc) y -> if (y > x) then (y, acc ++ [y]) else (y, acc)) (x,[]) xs
f2d_test1 = f2d [1..6] == [2..6]
f2d_test2 = f2d [3,(-2),8,7,11] == [8,11]
f2d_test3 = f2d [3,0,9] == [9]

--  e) Сформировать список, содержащий все локальные минимумы исходного списка.
f2e :: Ord a => [a] -> [a]
f2e [] = []
f2e [x] = [x]
f2e (x:y:[]) = if (x < y) then [x] else (if (y < x) then [y] else [])
f2e (x0:x1:xs) = addLast $ foldl (\((x, y), acc) z -> if (y < x) && (y < z) then ((y, z), acc ++ [y]) else ((y, z), acc)) ((x0, x1), start) xs
  where 
    start = if (x0 < x1) then [x0] else []
    addLast ((x, y), l) = if (y < x) then l ++ [y] else l
f2e_test1 = f2e [0,1,2,5,7,4] == [0,4]
f2e_test2 = f2e [2,1,7,5,6,8] == [1,5]
f2e_test3 = f2e [1,2,3] == [1]

--  f) Дана строка, содержащая слова, разделённые одним или несколькими пробелами. Сформировать
--     список слов этой строки.
f2f :: String -> [String]
f2f xs = snd $ foldr (\x (str, acc) -> if (x == ' ') then (if (str == "") then ("", acc) else ("", str:acc)) else (x:str, acc)) ("", []) (' ':xs)
f2f_test1 = f2f "Hello,  world!" == ["Hello,", "world!"]
f2f_test2 = f2f "one     two three" == ["one", "two", "three"]
f2f_test3 = f2f "   end   " == ["end"]

--  g) Разбить список на непересекающиеся подсписки длиной n элементов.

f2g :: Int -> [a] -> [[a]]
f2g n = (\(x, (y, _)) -> x ++ [y]) . foldl (\(acc, (list, r)) elem -> if (r == 0) then (acc ++ [list], ([elem], n-1)) else (acc, (list ++ [elem], r-1))) ([], ([], n))
f2g_test1 = f2g 3 [1,2,3,4,5,6,7,8] == [[1,2,3],[4,5,6],[7,8]]
f2g_test2 = f2g 2 "ababab" == ["ab","ab","ab"]
f2g_test3 = f2g 1 [1,2,3] == [[1],[2],[3]] 

--  h) Разбить список на подсписки длиной n элементов с перекрывающейся частью в k элементов (k < n).
f2h :: Int -> Int -> [a] -> [[a]]
f2h n k = (\(x, (y, _)) -> x ++ [y]) . foldl (\(acc, (list, r)) elem -> if (r == 0) then (acc ++ [list], (f2c k list ++ [elem], n-k-1)) else (acc, (list ++ [elem], r-1))) ([], ([], n))
f2h_test1 = f2h 3 1 [1,2,3,4,5,6,7,8] == [[1,2,3],[3,4,5],[5,6,7],[7,8]]
f2h_test2 = f2h 3 2 "ababab" == ["aba","bab","aba","bab"]
f2h_test3 = f2h 1 0 [1,2,3] == [[1],[2],[3]] 


--  k) Сформировать список, содержащий все начальные элементы списка, удовлетворяющие заданному предикату.
f2k :: (a -> Bool) -> [a] -> [a]
f2k p xs = snd $ foldl (\(flag, acc) x -> if flag then (if p x then (flag, acc ++ [x]) else (False, acc)) else (False, acc)) (True, []) xs
f2k_test1 = f2k (<3) [1,2,1,4,1,3,2,5] == [1,2,1]
f2k_test2 = f2k (=='a') "aaajahuuga" == "aaa"
f2k_test3 = f2k even [2,4,5,6,7,8] == [2,4]

--  l) Повторить каждый элемент списка заданное количество раз.
f2l :: Int -> [a] -> [a]
f2l n = foldr (\x acc -> replicate n x ++ acc) [] 
f2l_test1 = f2l 2 [1..4] == [1,1,2,2,3,3,4,4]
f2l_test2 = f2l 3 "why" == "wwwhhhyyy"
f2l_test3 = f2l 4 [1,0] == [1,1,1,1,0,0,0,0]

--  m) Удалить из списка повторяющиеся подряд идущие элементы.

--  n) Даны два списка одинаковой длины. Сформировать список, состоящий из результатов применения
--    заданной функции двух аргументов к соответствующим элементам исходных списков.
f2n :: (a -> a -> b) -> [a] -> [a] -> [b]
f2n p xs ys = snd $ foldl (\((z:zs), acc) x -> (zs, acc ++ [(p x z)])) (ys, []) xs

f2n_test1 = f2n (+) [1,2,3] [4,5,6] == [5,7,9]
f2n_test2 = f2n (*) [1,2,3] [4,5,6] == [4,10,18]
f2n_test3 = f2n mod [6,3] [2,2] == [0,1]

-- 3. Использование свёртки как носителя рекурсии (для запуска свёртки можно использовать список типа [1..n]).

--  a) Найти сумму чисел от a до b.
f3a :: Int -> Int -> Int
f3a a b = foldl (+) 0 [a..b]
f3a_test1 = f3a 5 12 == 68
f3a_test2 = f3a 1 5 == 15
f3a_test3 = f3a (-3) 10 == 49

--  b) Найти сумму факториалов чисел от a до b (повторные вычисления факториалов не допускаются).
f3b :: Int -> Int -> Int
f3b a b = foldl (+) 0 (scanl (*) start [a+1..b])
  where
    start = foldl (*) 1 [2..a]
f3b_test1 = f3b 1 4 == 33
f3b_test2 = f3b 3 5 == 150
f3b_test3 = f3b 2 6 == 872

--  с) Сформировать список из первых n чисел Фибоначчи.
f3c :: Int -> [Int]
f3c 1 = [0]
f3c 2 = [0,1]
f3c n = snd $ foldl (\((x, y), acc) _ -> ((y, x+y), acc ++ [x+y])) ((0, 1), [0,1]) [3..n]
f3c_test1 = f3c 15 == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377] 
f3c_test2 = f3c 1 == [0] 
f3c_test3 = f3c 3 == [0, 1, 1] 

--  d) Пользуясь рядом Тейлора, вычислить значение синуса заданного числа x (использовать n слагаемых).
f3d x n = foldl (\acc y -> acc + (-1)^y * x^(2*y+1) / product [1..(2*y+1)]) x [1..n-1]

--  e) Проверить, является ли заданное целое число простым.
f3e :: Int -> Bool
f3e 0 = False
f3e 1 = False
f3e 2 = True
f3e n = foldl (\flag x -> if n `mod` x == 0 then False else flag) True [2..n-1]
f3e_test1 = f3e 113 == True
f3e_test2 = f3e 76 == False
f3e_test3 = f3e 251 == True

{-
 4. Решить задачу о поиске пути с максимальной суммой в треугольнике (см. лекцию 3) при условии,
   что необходимо дополнительно найти сам путь (к примеру, в виде закодированных направлений спуска:
   0 - влево, 1 - вправо). В решении допускается использование любых стандартных функций.
-}

-- 5. Пусть числовые матрицы представлены списками строк. Реализовать следующие функции:

--  1) транспонирование матрицы;
--  2) сумма двух матриц;
--  3) произведение двух матриц.

{-
 6. Реализовать левую свёртку, пользуясь правой. Проанализировать поведение собственной реализации
  на бесконечных списках и сравнить его с поведением оригинальной foldl.
-}
