import Data.Char
import Data.List
{-
-Явная рекурсия в решениях хотя и допускается, но не приветствуется. Старайтесь обходиться стандартными
-функциями, используя при этом создание функций «на лету». Пытайтесь максимально упростить уже написанные
-решения, применяя подходящие функции из модуля Data.List и любых других модулей. Перед выполнением заданий
-изучите примеры из лекции по функциям высшего порядка. 
-}

{-
 1. Простейшие задачи на применение функций map и filter.
 1.1 Преобразовать данный список целых чисел следующим образом:
  a) увеличить все его элементы в два раза;
  b) увеличить все его элементы с четными значениями в два раза;
  с) обнулить все его элементы с нечетными значениями;
  d) удалить из него элементы, большие заданного числа k;
  e) отфильтровать его, оставив в списке только отрицательные числа;
  f) удалить из него все положительные чётные числа.
-}

f11a :: Integral a => [a] -> [a]
f11a = map (*2)

f11b :: Integral a => [a] -> [a]
f11b = map doubleEven 
  where
    doubleEven a
      | even a = a * 2
      | otherwise = a

f11c :: Integral a => [a] -> [a]
f11c = map zeroOdd
  where
    zeroOdd a
      | odd a = 0
      | otherwise = a

f11d :: Integral a => a -> [a] -> [a]
f11d k = filter (<=k)

f11e :: Integral a => [a] -> [a]
f11e = filter (<0)

f11f :: Integral a => [a] -> [a]
f11f = filter (\a -> (a <= 0) || (odd a))

{-
 1.2 Дан список декартовых координат точек на плоскости (пар вещественных чисел).
     Преобразовать его следующим образом:
  a) отфильтровать список так, чтобы в нём остались точки из заданной координатной четверти;
  b) преобразовать декартовы координаты в полярные.
-}

f12a :: Integer -> [(Double, Double)] -> [(Double, Double)]
f12a 1 = (filter (((>0).fst)).(filter ((>0).snd))) 
f12a 2 = (filter (((<0).fst)).(filter ((>0).snd))) 
f12a 3 = (filter (((<0).fst)).(filter ((<0).snd))) 
f12a 4 = (filter (((>0).fst)).(filter ((<0).snd)))
f12a _ = error "Wrong quarter!" 

f12b :: [(Double, Double)] -> [(Double, Double)]
f12b = map (\(x, y) -> (sqrt (x^2 + y^2), atan2 y x))

{-
 1.3 Дан список слов.
  a) Преобразовать все слова к верхнему регистру.
  b) Извлечь из него подсписок слов заданной длины.
  c) Извлечь из него подсписок слов, начинающихся с заданной буквы.
-}

f13a :: [String] -> [String]
f13a = map (map toUpper)

f13b :: Int -> [String] -> [String]
f13b l = filter ((==l).length) 

f13c :: Char -> [String] -> [String]
f13c c = filter ((==c).head) 

{-
2. Формирование числовых последовательностей (iterate).
 a) Список натуральных чисел, начиная с 0.
 b) Список чётных чисел.
 c) Список элементов последовательности: a0=1, an=(1+an-1)/2.
 d) Список символов английского алфавита.
 e) Список строк, представляющих n-значные двоичные числа.
-}

nats :: [Integer]
nats = iterate (+1) 0

evens :: [Integer]
evens = iterate (+2) 0

seq' :: [Double]
seq' = iterate ((/2).(+1)) 1

alphEng :: [Char]
alphEng = take 26 $ iterate (chr.(+1).ord) 'a'

{-
3. Группировка списков.
  a) Дан список символов. Сгруппировать подряд идущие символы по принципу: цифры — не цифры — ...
- b) Дан список пар вещественных чисел (координат точек на плоскости). Сгруппировать подряд идущие
- координаты точек, лежащие в одной координатной четверти.
- c) Дан список и ненулевое натуральное число n. Разбить список на подсписки длиной n каждый.
- Последний подсписок может содержать менее n элементов.
- d) Дан список и ненулевые натуральные числа n и m. Разбить список на перекрывающиеся подсписки
- длиной n элементов со сдвигом относительно предыдущего подсписка на m элементов.
  e) Дан список. Определить длину самого длинного подсписка, содержащего подряд идущие одинаковые элементы.
-}

{-f3a :: [Char] -> [[Char]]
f3a = groupBy isSame
  where
    isSame x1 x2 = ((isDigit x1) && (isDigit x2)) || ((not $ isDigit x1) && (not $     isDigit x2))
-}
f3a :: [Char] -> [[Char]]
f3a = groupBy (\x1 x2 -> ((isDigit x1) && (isDigit x2)) || ((not $ isDigit x1) && (not $ isDigit x2)))

f3b :: [(Double, Double)] -> [[(Double, Double)]]
f3b = groupBy sameQuarter
  where
    sameQuarter (x1,y1) (x2,y2)
      | (x1 > 0) && (y1 > 0) = (x2 > 0) && (y2 > 0) 
      | (x1 > 0) && (y1 < 0) = (x2 > 0) && (y2 < 0)
      | (x1 < 0) && (y1 > 0) = (x2 < 0) && (y2 > 0)
      | (x1 < 0) && (y1 < 0) = (x2 < 0) && (y2 < 0)
      | otherwise = False

f3c :: [a] -> Int -> [[a]]
f3c [] _ = []
f3c xs n = [take n xs] ++ (f3c (drop n xs) n)

f3d :: [a] -> Int -> Int -> [[a]]
f3d [] _ _ = []
f3d xs n m = [take n xs] ++ (f3d (drop m xs) n m)

-- Должно быть True
test_f3d = f3d [1..10] 4 2 == [[1,2,3,4],[3,4,5,6],[5,6,7,8],[7,8,9,10],[9,10]]

f3e :: Eq a => [a] -> Int
f3e xs = maximum $ map length $ groupBy (==) xs

{-
4. Разные задачи.
- a) Дан текст в виде строки символов, содержащий среди прочего числовые данные. Посчитать количество
- всех упоминающихся в тексте чисел.
- b) Найти сумму всех чисел Фибоначчи, удовлетворяющих заданному предикату, в указанном промежутке
- (например: все чётные от 1 до 106).
- c) Дана строка текста и число n. Сформировать список, содержащий n самых часто используемых
- в строке символов.
- d) Дан список чисел. Сформировать список локальных максимумов исходного списка. Локальным максимумом
- называется элемент, больший своих соседей.
 e) Дан список. Продублировать все его элементы.
-}

f4a :: String -> Int
f4a s = length $ filter (isDigit.head) $ f3a s

f4b :: (Int -> Bool) -> Int -> Int -> Int
f4b p a b = sum $ filter p $ dropWhile (<=a) $ takeWhile (<=b) fibs
  where
    fibs = 0 : 1 : zipWith (+) fibs (tail fibs)

f4c :: Int -> String -> String
f4c n = (take n) . (map head) . reverse . sortBy (\x y -> compare (length x) (length y)) . group . sort 

f4e :: [a] -> [a]
f4e = concat . map (\x -> [x,x])

